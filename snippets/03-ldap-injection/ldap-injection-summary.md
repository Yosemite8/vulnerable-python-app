# ✅ LDAP Injection に関する要点整理（CWE-90）

## 🔍 基本構文の理解

LDAP フィルターは構造的に強力で、以下のような論理演算を組み合わせることができる：

- `&`：AND（すべての条件を満たす）
- `|`：OR（いずれかの条件を満たす）
- `!`：NOT（条件を否定）

例：
```ldap
(&(uid=admin)(userPassword=secret))
```
→ `uid=admin` かつ `userPassword=secret` に一致するエントリを検索。

---

## ⚠️ LDAP Injection の典型例と攻撃者の狙い

攻撃者は、LDAPフィルターが**ユーザー入力を文字列連結で構築している**ケースを狙う。

例：

```python
ldap_filter = f"(&(uid={username})(userPassword={password}))"
```

攻撃者が次のような username を入力：

```text
admin)(|(uid=*))
```

→ 構築されるLDAPフィルター：

```ldap
(&(uid=admin)(|(uid=*))(userPassword=anything))
```

このように、**構文上は壊れていないが、意味的にフィルターのロジックを乗っ取る**ことができる。

---

## ✅ 実際の評価と攻撃の成立条件

- LDAPサーバは、与えられた**フィルター全体を一つの構造として評価**する。
- `(|(uid=*))` はほぼ常に true（"uid属性を持つすべてのエントリ"）
- しかし `userPassword=anything` に**実際に一致するユーザーがいなければ**結果は返らない。

つまり：

> **「uidのバイパスには成功するが、passwordチェックを満たせなければ結局一致しない」**

このため、**Injectionによる認証回避を狙うには、もっと巧妙な構文破壊やOR条件の配置**が必要になる。

---

## 🧠 攻撃者の前提とアプリ開発者の誤解

- 攻撃者は、「アプリ側が username と password を分離してフィルターを構築している」**と思い込んでいる（と期待している）**
- しかし実際には、**1つのLDAPフィルター文字列に連結されている**ので、そこに構文挿入できればロジック全体を壊せる

---

## 🚨 危険なパターン

```python
ldap_filter = f"(&(uid={username})(userPassword={password}))"
```

このような文字列連結は、構文インジェクションの温床になる。

---

## 🛡️ 対策

- `ldap3.utils.conv.escape_filter_chars()` を用いて、LDAP用に入力を適切にエスケープする
- フィルターを構築する際は文字列連結を避け、可能であればフィルター構築ライブラリを使用する
- ユーザー入力は「そのまま構文に入れる」のではなく、意味論レベルで制限をかける（正規表現など）

---

## ✅ 結論

LDAP Injection は、**LDAPの強力な構文機能と、アプリケーションの安易な文字列連結の組み合わせによって成立する**。

アプリケーション側が入力の正規化・サニタイズを怠ると、フィルター構文全体を乗っ取られる可能性がある。
